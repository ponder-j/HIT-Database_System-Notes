# 数据库作业-4 详细解答

## 第1题：连接算法I/O代价分析

### 题目条件
- 关系R(A,B): 20000个元组，主键R.A
- 关系S(B,C): 60000个元组，主键S.B
- 一块可容纳: 20个R元组 或 30个S元组
- R和S均采用聚簇存储，按主键递增排序
- 缓冲区页数: M = 41

### 基本计算
- R占用块数: ⌈20000/20⌉ = 1000块
- S占用块数: ⌈60000/30⌉ = 2000块

---

### (1) 基于元组的嵌套循环连接算法

**算法描述：**
- 外层循环遍历R的每个元组
- 对R的每个元组，扫描整个S关系查找匹配

**I/O分析：**

1. **读取R关系**: 1000次I/O（读一次）

2. **对R的每个元组扫描S**:
   - R有20000个元组
   - 每个元组需要读取整个S: 2000次I/O
   - 总计: 20000 × 2000 = 40,000,000次I/O

3. **总I/O次数**: 1000 + 40,000,000 = **40,001,000次I/O**

**优化说明：**
如果使用基于块的嵌套循环（Block Nested Loop），I/O会大幅减少：
- 外层读R: 1000次
- 对R的每一块，扫描整个S: 1000 × 2000 = 2,000,000次
- 总计: 1000 + 2,000,000 = 2,001,000次I/O

---

### (2) 归并连接算法

**前提条件：**
- R和S已按连接属性B排序
- 可用缓冲区: M = 41页

**算法步骤：**

由于R和S已经按主键排序，且R.B是外键参照S.B，我们假设数据已按B排序。

**方法1: 直接归并（如果已按B排序）**
- 读取R: 1000次I/O
- 读取S: 2000次I/O
- 总计: **3000次I/O**

**方法2: 如果需要排序后归并**

1. **排序R（按B）**:
   - 初始归并段数: ⌈1000/41⌉ = 25段
   - 归并趟数: ⌈log₄₀(25)⌉ = 1趟
   - 排序I/O: 2 × (1 + 1) × 1000 = 4000次

2. **排序S（按B）**:
   - 初始归并段数: ⌈2000/41⌉ = 49段
   - 归并趟数: ⌈log₄₀(49)⌉ = 2趟
   - 排序I/O: 2 × (1 + 2) × 2000 = 12000次

3. **归并连接**:
   - 读取R: 1000次
   - 读取S: 2000次
   - 归并I/O: 3000次

4. **总I/O**: 4000 + 12000 + 3000 = **19000次I/O**

**本题答案（已排序）**: **3000次I/O**

---

### (3) 结果存储空间计算

**已知条件：**
- R.B是外键，参照S.B
- R⨝S结果元组大小 = R元组大小 × 1.2
- R⨝S结果元组大小 = S元组大小 × 1.8

**分析：**

1. **R元组大小**: 设一块可容纳20个R元组，则块大小 = 20 × R元组大小

2. **S元组大小**: 设一块可容纳30个S元组，则块大小 = 30 × S元组大小

3. **从比例关系**:
   - 块大小 = 20 × R元组大小 = 30 × S元组大小
   - R元组大小 / S元组大小 = 30/20 = 1.5

4. **结果元组大小**:
   - 设R元组大小 = r, S元组大小 = s
   - 结果元组大小 = 1.2r = 1.8s
   - 验证: 1.2r = 1.2 × 1.5s = 1.8s ✓

5. **结果元组数量**:
   - 由于R.B是外键参照S.B，每个R元组最多匹配1个S元组
   - 结果元组数 ≤ 20000

6. **每块容纳结果元组数**:
   - 块大小 = 20r
   - 结果元组大小 = 1.2r
   - 每块容纳: 20r / 1.2r = 16.67 ≈ 16个结果元组

7. **所需块数**:
   - 最坏情况（所有R元组都匹配）: ⌈20000/16⌉ = **1250块**
   - 实际可能更少，取决于实际匹配的元组数

**答案**: **1250块**

---

## 第2题：索引连接代价

### 题目条件
- R(X,Y): 1000个元组，占用⌈1000/20⌉ = 50块
- S(Y,Z): 1500个元组，占用⌈1500/30⌉ = 50块
- S中Y不同值的个数: 20

---

### (1) S.Y上有聚簇索引

**算法：索引嵌套循环连接**

1. **扫描R**: 50次I/O

2. **对R的每个元组，通过索引查找S**:
   - R有1000个元组
   - S中Y有20个不同值，平均每个值对应: 1500/20 = 75个元组
   - 聚簇索引：相同Y值的元组存储在一起
   - 每个Y值的元组占用块数: ⌈75/30⌉ = 3块
   - 索引查找: 1次I/O（假设索引在内存或很小）
   - 读取匹配数据块: 3次I/O
   - 每次查找总计: 1 + 3 = 4次I/O

3. **总I/O**:
   - 读R: 50次
   - 1000次索引查找: 1000 × 4 = 4000次
   - **总计: 4050次I/O**

---

### (2) S.Y上有非聚簇索引

**区别：非聚簇索引中，相同Y值的元组可能分散存储**

1. **扫描R**: 50次I/O

2. **对R的每个元组，通过索引查找S**:
   - 索引查找: 1次I/O
   - 最坏情况：75个匹配元组分散在75个不同块中
   - 读取数据: 75次I/O（每个元组可能在不同块）
   - 每次查找总计: 1 + 75 = 76次I/O

3. **总I/O**:
   - 读R: 50次
   - 1000次索引查找: 1000 × 76 = 76000次
   - **总计: 76050次I/O**

**优化考虑：**
实际情况可能介于两者之间，因为有些元组可能在同一块中。

---

## 第3题：查询优化

### 题目条件
- S(S#, SNAME, AGE, SEX): 1000条元组
- C(C#, CNAME, TEACHER): 50条元组
- SC(S#, C#, GRADE): 10000条元组
- 满足选修数据库课程的元组: 150条

### SQL查询
```sql
SELECT SNAME
FROM S, SC, C
WHERE SC.S#=S.S# AND SC.C#=C.C# AND CNAME="数据库"
```

---

### (1) 关系代数表达式

**标准形式（直接转换）：**

π<sub>SNAME</sub>(σ<sub>SC.S#=S.S# ∧ SC.C#=C.C# ∧ CNAME="数据库"</sub>(S × SC × C))

或分解为：

π<sub>SNAME</sub>(σ<sub>CNAME="数据库"</sub>(S ⨝<sub>S.S#=SC.S#</sub> SC ⨝<sub>SC.C#=C.C#</sub> C))

---

### (2) 查询计划树

**优化前的查询计划树：**

```
         π(SNAME)
            |
         σ(CNAME="数据库")
            |
         ⨝(SC.C#=C.C#)
            |
         ⨝(S.S#=SC.S#)
         /        \
        S          SC
                    \
                     C
```

或者笛卡尔积形式：

```
              π(SNAME)
                 |
    σ(SC.S#=S.S# ∧ SC.C#=C.C# ∧ CNAME="数据库")
                 |
                 ×
            /    |    \
           S    SC     C
```

**优化后的查询计划树：**

应用启发式规则：
1. **尽早执行选择操作**（下推选择）
2. **尽早执行投影操作**（下推投影）
3. **将选择和笛卡尔积合并为连接**
4. **先执行选择度高的操作**

```
         π(SNAME)
            |
         ⨝(S.S#=SC.S#)
         /        \
        S       ⨝(SC.C#=C.C#)
                /          \
              SC      σ(CNAME="数据库")
                            |
                            C
```

**优化理由：**
1. 先对C表进行选择σ(CNAME="数据库")，大幅减少元组数
2. 先连接SC和筛选后的C，减少中间结果
3. 最后连接S表并投影

---

### (3) 中间结果大小计算

**优化前（假设先做笛卡尔积）：**

1. **S × SC**: 1000 × 10000 = 10,000,000条
2. **结果 × C**: 10,000,000 × 50 = 500,000,000条
3. **σ(条件)**: 约150条（满足选修数据库课程）
4. **π(SNAME)**: 150条

**优化后：**

1. **σ(CNAME="数据库")(C)**: 
   - 输入: 50条
   - 输出: 1条（假设只有1门数据库课程）

2. **SC ⨝ σ(C)**: 
   - SC: 10000条
   - 筛选后的C: 1条
   - 结果: 150条（题目已给出）

3. **S ⨝ (SC ⨝ C)**:
   - S: 1000条
   - SC ⨝ C: 150条
   - 结果: 150条（每个SC记录对应一个学生）

4. **π(SNAME)**:
   - 输入: 150条
   - 输出: 150条（或更少，如果有学生多次选课）

**对比：**
- 优化前最大中间结果: **500,000,000条**
- 优化后最大中间结果: **150条**
- 优化效果显著！

---

## 第4题：查询计划树

### SQL查询
```sql
SELECT C.name
FROM Student S, Course C, Enrollment E
WHERE S.sid = E.sid
  AND C.cid = E.cid
  AND S.major = 'Computer Science'
  AND C.credit >= 90;
```

---

### (1) 初始查询计划树

```
              π(C.name)
                 |
    σ(S.sid=E.sid ∧ C.cid=E.cid ∧ 
      S.major='CS' ∧ C.credit>=90)
                 |
                 ×
            /    |    \
           S     C     E
```

或连接形式：

```
         π(C.name)
            |
         σ(S.major='CS' ∧ C.credit>=90)
            |
         ⨝(C.cid=E.cid)
            |
         ⨝(S.sid=E.sid)
         /        \
        S          E
                    \
                     C
```

---

### (2) 优化后的查询计划树（有索引）

**索引信息：**
- Student.major 上有索引
- Enrollment.sid 上有索引

**优化策略：**
1. 利用索引尽早过滤
2. 选择合适的连接顺序
3. 使用索引连接

```
            π(C.name)
               |
            ⨝(E.cid=C.cid)
            /          \
         ⨝(S.sid=E.sid)   σ(credit>=90)
         /        \              |
  σ(major='CS')   IndexScan      C
   (IndexScan)    (E.sid)
        |
        S
```

**优化说明：**

1. **Student表**: 使用major索引，σ(major='CS')直接通过索引访问

2. **Enrollment表**: 使用sid索引进行索引连接
   - 对每个满足条件的Student.sid，通过索引快速查找Enrollment

3. **Course表**: 先应用σ(credit>=90)过滤

4. **连接顺序**: 
   - 先连接Student和Enrollment（利用两个索引）
   - 再连接Course（已过滤）

5. **索引连接优势**:
   - 避免全表扫描
   - 减少I/O次数
   - 减少中间结果大小

---

## 第5题：自然连接查询优化

### SQL查询
```sql
SELECT author 
FROM B NATURAL JOIN S NATURAL JOIN L
WHERE date = '2023-11-01' AND dept = 'Math';
```

---

### (1) 逻辑查询计划树

**自然连接展开：**
- B NATURAL JOIN L: 连接属性为bno
- (B⨝L) NATURAL JOIN S: 连接属性为sno

```
            π(author)
               |
    σ(date='2023-11-01' ∧ dept='Math')
               |
             ⨝(sno)
            /      \
          ⨝(bno)    S
         /      \
        B        L
```

---

### (2) 优化后的逻辑查询计划树

**启发式优化规则：**
1. 选择操作尽可能早执行（选择下推）
2. 投影操作尽可能早执行（投影下推）
3. 将选择和笛卡尔积合并为连接
4. 选择合适的连接顺序

**优化后：**

```
         π(author)
            |
         ⨝(sno)
         /      \
       ⨝(bno)   σ(dept='Math')
      /      \         |
     B    σ(date='2023-11-01')  S
               |
               L
```

或更优化的顺序：

```
            π(author)
               |
            ⨝(bno)
            /      \
           B     ⨝(sno)
                 /      \
  σ(date='2023-11-01')  σ(dept='Math')
         |                    |
         L                    S
```

**优化理由：**

1. **选择下推到基本关系**:
   - σ(date='2023-11-01')下推到L表
   - σ(dept='Math')下推到S表
   - **理由**: 尽早过滤减少参与连接的元组数量，大幅降低中间结果大小

2. **连接顺序调整**:
   - 先连接L和S（两个都已过滤）
   - 再连接B
   - **理由**: 
     - 借书表L经过日期过滤后元组数很少（某一天的借书记录）
     - 学生表S经过系别过滤后元组数也较少（数学系学生）
     - 两个小表连接产生的中间结果远小于原始表连接

3. **投影下推**（可选）:
   - 可以在连接前只保留需要的属性
   - π(bno, sno)应用到L
   - π(sno)应用到S
   - π(bno, author)应用到B

4. **估算效果**:
   - 假设L表有100000条记录，过滤后可能只有50-100条
   - 假设S表有10000条记录，数学系可能有500-1000条
   - 先连接过滤后的小表，中间结果可能只有几十到几百条
   - 远好于先连接大表再过滤

**最终优化的完整计划树（含投影下推）：**

```
         π(author)
            |
         ⨝(bno)
         /      \
  π(bno,author)  ⨝(sno)
        |        /      \
        B   π(sno,bno)  π(sno)
              |            |
  σ(date='2023-11-01') σ(dept='Math')
              |            |
              L            S
```

---

## 总结

本作业涵盖了数据库查询优化的核心内容：

1. **连接算法I/O代价分析**: 理解不同连接算法的性能特征
2. **索引连接**: 掌握索引对查询性能的影响
3. **启发式查询优化**: 应用选择下推、投影下推等优化规则
4. **查询计划树**: 能够绘制和优化查询计划
5. **代价估算**: 计算中间结果大小，评估优化效果

**关键优化原则：**
- 尽早过滤（选择下推）
- 减少中间结果
- 合理利用索引
- 选择合适的连接顺序
- 避免笛卡尔积