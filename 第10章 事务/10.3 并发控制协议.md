## 基于锁的协议
### 一次封锁法
### 顺序封锁法
### 死锁的检测与恢复
- 如何检测死锁？
#### 超时法
 - 如果一个事务的等待时间超过了规定的时限，就认为发生了死锁
 - 优点：实现简单
 - 缺点：
	 - 有可能误判
	 - 时限不好确定
#### 等待图法
- 用等待图动态反映所有事务的等待情况
	- 事务等待图是一个有向图 G = (T, U)
	- T 为结点集合，每个结点
	- U 为边的集合

#### 死锁的恢复
- 选择 victim：必须决定回滚哪一个（或哪一些）事务以打破死锁，应使事务回滚代价最小
	- 事务已经计算了多久，还要多久
	- 已使用多少数据项
	- 。。
	- 。。
- 方法
	- 。。
	- 。。

### 两段锁并发控制协议
#### 两段锁协议
- 两段锁协议 Two-Phase Locking : 2PL
	- 要求每个事务分两个阶段进行数据项的加锁与解锁
		- 加锁阶段：只能申请加锁不能释放
		- 解锁阶段：只能释放不能申请加锁
	- 开始。加锁。
	- 第一次释放。解锁

eg. 
r = READ(), w = WRITE()
$T_{11}$: r $a_{1}$, r $a_{2}$, ..., r $a_{n}$, w $a_{1}$
$T_{22}$: r $a_{1}$, r $a_{2}$, display $a_{1} + a_{2}$
- 如果使用两段锁，必须给 a_1 加互斥锁，但是不管怎么加都相当于并行变串行了
- 可以改善

- 改善的两段锁协议：
	- 当事务 $T_{i}$ 提交一个 READ(Q) 操作时 ，系统先执行 LOCK-S(Q) 操作，然后再执行 READ(Q) 操作。
	- 当事务 $T_{i}$ 提交一个 WRITE(Q) 操作时，系统检查 $T_{i}$ 是否已持有 Q 上的一个共享锁。如果这样，系统先执行 UPGRADE(Q) 操作，然后再执行 WRITE(Q) 操作；否则，系统先执行 LOCK-X(Q) 操作，然后再执行 WRITE(Q) 操作。
- 可以证明，**任何一个满足两段锁协议的合理调度都是冲突可串行的**。但是，并非每组具有冲突可串行调度的事务都有一个满足两段锁协议的调度。

- 一个事务终止可能导致其他事务**级联终止**
- 如果一个调度中任意事务在结束前由它写入的数据库对象的值没有被其他事务读过/修改过，则该调度称为严格调度
	- 严格调度不会引发级联终止

#### 强两段锁协议
- Strong Strict Two-Phase Locking: SSTPL
- 加锁阶段
	- 与 2PL 相同
- 解锁阶段
	- 当事务结束时，释放其获得的全部锁
- 保证生成严格的冲突可串行化调度，不会产生级联终止

## 基于时间戳的协议
- Timestamp
- 另一种决定事务可串行化次序的方法是事先选定事务的次序，最常见的方法是时间戳排序机制
- 对于系统中每个事务 $T_{i}$ , 我们把一个唯一的时间戳与它联系起来，记为 $TS(T_{i})$
	- 系统时钟
	- 逻辑计数器
- 如果有一个新事务 $T_{j}$ 进入系统，则 $TS(T_{i}) < TS(T_{j})$ 
- 事务时间戳决定了**串行化顺序**
	- Ti 视角
		- Ti 读操作要在 Tj 写操作之前
		- Ti 写操作要在 Tj 读操作和写操作之前
	- Tj 视角
		- Tj 读操作要在 Ti 写操作之后
		- Tj 写操作要在 Ti 读操作和写操作之后
- 每个数据项 Q 需要与两个时间戳值xian