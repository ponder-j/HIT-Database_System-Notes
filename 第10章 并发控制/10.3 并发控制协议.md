## 基于锁的协议
### 一次封锁法
### 顺序封锁法
### 死锁的检测与恢复
- 如何检测死锁？
#### 超时法
 - 如果一个事务的等待时间超过了规定的时限，就认为发生了死锁
 - 优点：实现简单
 - 缺点：
	 - 有可能误判
	 - 时限不好确定
#### 等待图法
- 用等待图动态反映所有事务的等待情况
	- 事务等待图是一个有向图 G = (T, U)
	- T 为结点集合，每个结点
	- U 为边的集合

#### 死锁的恢复
- 选择 victim：必须决定回滚哪一个（或哪一些）事务以打破死锁，应使事务回滚代价最小
	- 事务已经计算了多久，还要多久
	- 已使用多少数据项
	- 。。
	- 。。
- 方法
	- 。。
	- 。。

### 两段锁并发控制协议
#### 两段锁协议
- 两段锁协议 Two-Phase Locking : 2PL
	- 要求每个事务分两个阶段进行数据项的加锁与解锁
		- 加锁阶段：只能申请加锁不能释放
		- 解锁阶段：只能释放不能申请加锁
	- 开始。加锁。
	- 第一次释放。解锁

eg. 
r = READ(), w = WRITE()
$T_{11}$: r $a_{1}$, r $a_{2}$, ..., r $a_{n}$, w $a_{1}$
$T_{22}$: r $a_{1}$, r $a_{2}$, display $a_{1} + a_{2}$
- 如果使用两段锁，必须给 a_1 加互斥锁，但是不管怎么加都相当于并行变串行了
- 可以改善

- 改善的两段锁协议：
	- 当事务 $T_{i}$ 提交一个 READ(Q) 操作时 ，系统先执行 LOCK-S(Q) 操作，然后再执行 READ(Q) 操作。
	- 当事务 $T_{i}$ 提交一个 WRITE(Q) 操作时，系统检查 $T_{i}$ 是否已持有 Q 上的一个共享锁。如果这样，系统先执行 UPGRADE(Q) 操作，然后再执行 WRITE(Q) 操作；否则，系统先执行 LOCK-X(Q) 操作，然后再执行 WRITE(Q) 操作。
- 可以证明，**任何一个满足两段锁协议的合理调度都是冲突可串行的**。但是，并非每组具有冲突可串行调度的事务都有一个满足两段锁协议的调度。

- 一个事务终止可能导致其他事务**级联终止**
- 如果一个调度中任意事务在结束前由它写入的数据库对象的值没有被其他事务读过/修改过，则该调度称为严格调度
	- 严格调度不会引发级联终止

#### 强两段锁协议
- Strong Strict Two-Phase Locking: SSTPL
- 加锁阶段
	- 与 2PL 相同
- 解锁阶段
	- 当事务结束时，释放其获得的全部锁
- 保证生成严格的冲突可串行化调度，不会产生级联终止

## 基于时间戳的协议
- Timestamp
- 另一种决定事务可串行化次序的方法是事先选定事务的次序，最常见的方法是时间戳排序机制
- 对于系统中每个事务 $T_{i}$ , 我们把一个唯一的时间戳与它联系起来，记为 $TS(T_{i})$
	- 系统时钟
	- 逻辑计数器
- 如果有一个新事务 $T_{j}$ 进入系统，则 $TS(T_{i}) < TS(T_{j})$ 
- 事务时间戳决定了**串行化顺序**
	- $T_{i}$ 视角
		- $T_{i}$ 读操作要在 $T_{j}$ 写操作之前
		- $T_{i}$ 写操作要在 $T_{j}$ 读操作和写操作之前
	- Tj 视角
		- $T_{j}$ 读操作要在 $T_{i}$ 写操作之后
		- $T_{j}$ 写操作要在 $T_{i}$ 读操作和写操作之后
- 每个数据项 Q 需要与两个时间戳值关联
	- W-timestamp(Q): 表示成功执行 write(Q) 的所有事务的最大时间戳
	- R-timestamp(Q): 表示成功执行 read(Q) 的所有事务的最大时间戳
### 时间戳排序协议
- 假设事务 $T_{i}$ 发出 read(Q)
	- 若 $TS(T_{i})$ < W-timestamp(Q) ，则 $T_{i}$ 需要读如的 Q 值已被覆盖。因此 read 操作被拒绝，$T_{i}$ 回滚
	- 若 $TS(T_{i})$ >= W-timestamp(Q)，则执行 read 操作，R-timestamp(Q) 被设置为 max($TS(T_{i})$, R-timestamp(Q))
- 假设事务 $T_{i}$ 发出 write(Q)
	- 若 $TS(T_{i})$ < R-timestamp(Q) ，则 $T_{i}$ 产生的 Q 值是先前所需要的值，且系统已假定该值不会产生。因此 write 操作被拒绝，$T_{i}$ 回滚
	- 若 $TS(T_{i})$ < W-timestamp(Q)，则 $T_{i}$ 试图写入的 Q 值已过时。因此 write 操作被拒绝，$T_{i}$ 回滚
	- 其他情况，执行 write 操作，W-timestamp(Q) 被设置为 $TS(T_{i})$

- 问题：如果 $T_{i}$ 写入 Q 的值被 $T_{j}$ 覆盖且中间没有读 Q 的操作，那么 $T_{i}$ 无论如何没必要回滚

- 优点
	- 保证冲突可串行化
	- 任何事务无需等待，保证无死锁
- 缺点
	- 一系列冲突的短事务可能引起长事务反复重启，导致长事务饿死
	- 可能产生不可恢复的调度
### Thomas 写规则
- 假设事务 $T_{i}$ 发出 read(Q), 处理方法与时间戳排序协议相同
- 假设事务 $T_{i}$ 发出 write(Q)
	- 若 $TS(T_{i})$ < R-timestamp(Q), 则 $T_{i}$ 产生的 Q 值是先前所需要的值，且系统已假定该值不会产生。因此 write 操作被拒绝，$T_{i}$ 回滚
	- **若 $TS(T_{i})$ < W-timestamp(Q), 则 $T_{i}$ 试图写入的 Q 值已过时。因此这个 write 操作可忽略**
	- 其他情况，执行 write 操作，W-timestamp(Q) 被设置为 $TS(T_{i})$

## 多版本机制
- 主要思想：
	- 每个 write(Q) 操作创建 Q 的一个新版本
	- 当事务发出一个 read(Q) 操作时，并发控制管理器选择 Q 的一个版本进行读取
	- 必须保证用于读取的版本的选择能够保持可串行性
	- 一个事务能够快速容易地判定读取哪个版本的数据项是关键
- 可分为多版本时间戳排序机制和多版本两段锁机制
### 多版本时间戳排序机制
- 对于每个数据项 Q，有一个版本序列 $<Q_{1}, Q_{2}, \cdots, Q_{m}>$ 与之关联，每个版本 $Q_{k}$ 包含
- 。。
- 设事务 $T_{i}$ 发出 read(Q) / write(Q) 操作，$Q_{k}$ 满足 $\max(Q_{j} | \text{W-timestamp}(Q_{j})\leq TS(T_{i}))$
	- 读操作：
	- 写操作：
- 删除不需要的版本
	- 如果某数据项的两个版本 $Q_{k}$ , $Q_{j}$ ，这两个版本的 W-timestamp 都小于系统中最老的事务的时间戳，那么删除 $Q_{k}$ 和 $Q_{j}$ 中较旧的版本
- 优点
	- 读请求从不失败且不必等待
- 缺点
	- 读取数据项要求更新 R-timestamp 字段，（可能）产生两次潜在的磁盘访问
	- 事务冲突通过回滚而不是等待来解决，开销可能大
	- 不保证可恢复性和无级联性
	- 一个数据维护多个版本和多个时间戳，增加代价
### 多版本两段锁机制
- 对只读事务和更新事务加以区分
- 。。
- 


