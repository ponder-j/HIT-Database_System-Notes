输入关系的约束
- 具有相同的属性集合
- 属性的排列顺序必须也相同

3 个常用的算法（以集合差为例）
- 一趟集合差算法
- 基于哈希的集合差算法
- 基于排序的集合差算法

### 一趟集合差算法
#### 算法流程
```
1. // 构建(build)阶段
2. 在M-1个可用内存页中建立一个内存查找结构(哈希表或平衡二叉树),查找键是整个元组
3. for S的每一块P do
4.     将P读入缓冲池
5.     将P中元组插入内存查找结构
6. // 探测(probe)阶段
7. for R的每一块P do
8.     将P读入缓冲池
9.     for P中每条元组t do
10.        if t不在于内存查找结构中 then
11.            将t写入输出缓冲区
```
#### 算法分析
- I/O 代价：$B(R) + B(S)$
- 可用内存页数要求：$B(S) \leq M-1$

### 基于哈希的集合差算法
#### 算法流程
```
1. // 哈希分桶(与基于哈希的去重算法的分桶方法相同)
2. 将R的元组哈希到M-1个桶R₁, R₂,..., R_{M-1}中(哈希键为整个元组)
3. 将S的元组哈希到M-1个桶S₁, S₂,..., S_{M-1}中(哈希键为整个元组)
4. // 逐桶计算集合差
5. for i = 1, 2,..., M - 1 do
6.     使用一趟集合差(one-pass set difference)算法计算R_i - S_i,并将结果写入输出缓冲区
```
#### 算法分析
- I/O 代价：$3B(R) + 3B(S)$
- 可用内存页数要求：$B(S)\leq (M-1)^2$

### 基于排序的集合差算法
#### 算法流程
```
1. // 创建归并段
2. 将R划分为⌈B(R)/M⌉个归并段(每个归并段按整个元组进行排序)
3. 将S划分为⌈B(S)/M⌉个归并段(每个归并段按整个元组进行排序)
4. // 归并
5. 读入R和S的每个归并段的第1页
6. repeat
7.     找出输入缓冲区中最小的元组t
8.     if t ∈ R且t ∉ S then
9.         将t写入输出缓冲区
10.    从输入缓冲区中删除t的所有副本
11.    任意输入缓冲页中的元组若归并完毕,则读入其归并段的下一页
12. until R的所有归并段都已归并完毕
```
#### 算法分析
- I/O 代价：$3B(R) + 3B(S)$
- 可用内存页数要求：$B(R)+B(S)\leq M^2$

