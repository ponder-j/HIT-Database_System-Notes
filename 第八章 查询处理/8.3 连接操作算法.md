$R(X, Y) \bowtie S(Y,Z)$
基本符号：
- $T(R)$: 关系 R 的元组数
- $T(S)$: 关系 S 的元组数
- $B(R)$: 关系 R 的块数
- $B(S)$: 关系 S 的块数
- $M$: 缓冲区可用内存页数
- $V(R, A)$: 关系 R 的属性集 A 的不同值的个数
- $V(S, A)$: 关系 S 的属性集 A 的不同值的个数

### 一趟连接算法 One-Pass Join
#### 算法流程
假设 $B(S)<B(R)$
```
// 构建(build)阶段
1. 构建阶段
2. 在M-1个可用内存页中建立一个内存查找结构(哈希表或平衡二叉树)，查找键是S.Y
3. for S的每一块P
4.     将P读入缓冲区
5.     将P中元组插入内存查找结构
// 探测(probe)阶段
6. 探测阶段
7. for R的每一块P do
8.     将P读入缓冲区
9.     for P中每条元组r do
10.        for 内存查找结构中每条键值等于r.Y的元组s do
11.            连接r和s，并将结果写入输出缓冲区。
```
![[Pasted image 20251013102655.png]]
#### 算法分析
- I/O 代价：$B(R)+B(S)$
	- build 阶段，S 的每块只读一次
	- probe 阶段，R 的每块只读一次
- 可用内存页数要求：$B(S) \leq M-1$
	- 内存查找结构约占 B(S) 页
- I/O 代价小，但内存开销大

### 基于元组的嵌套循环连接 Tuple-based Nested-Loop Join
#### 算法流程
小的放外层循环更合适
```
for S的每个元组s do
	for R的每个元组r do
		if r和s满足连接条件 then
			连接 rs，结果写入输出缓冲区
```
#### 算法分析
- I/O 代价：$T(S)(T(R)+1)$
	- 外关系 S 的每个元组只读一次，每次产生一个 IO
	- 内关系 R 的每个元组读 T(S) 次，每次产生一个 IO
- 可用内存页数要求：$M \geq 2$
	- 1 页作为读 S 的缓冲区
	- 1 页作为读 R 的缓冲区
#### 算法扩展
- 假设 B(S) < B(R)
- 可用内存数为 M
```
for S的每A块元组中的任意元素s do
	for R的每(M-A)块元组中的任意元组r do
		if r和s满足连接条件 then
			连接 rs，结果写入输出缓冲区
```
- I/O 代价：$(B(S)/A) \times (B(R)+A)$
- 相同内存页数 M 下，A 越大 I/O 代价越小，最优 A=M-1