$R(X, Y) \bowtie S(Y,Z)$
基本符号：
- $T(R)$: 关系 R 的元组数
- $T(S)$: 关系 S 的元组数
- $B(R)$: 关系 R 的块数
- $B(S)$: 关系 S 的块数
- $M$: 缓冲区可用内存页数
- $V(R, A)$: 关系 R 的属性集 A 的不同值的个数
- $V(S, A)$: 关系 S 的属性集 A 的不同值的个数

### 一趟连接算法 One-Pass Join
#### 算法流程
假设 $B(S)<B(R)$
```
// 构建(build)阶段
1. 构建阶段
2. 在M-1个可用内存页中建立一个内存查找结构(哈希表或平衡二叉树)，查找键是S.Y
3. for S的每一块P
4.     将P读入缓冲区
5.     将P中元组插入内存查找结构
// 探测(probe)阶段
6. 探测阶段
7. for R的每一块P do
8.     将P读入缓冲区
9.     for P中每条元组r do
10.        for 内存查找结构中每条键值等于r.Y的元组s do
11.            连接r和s，并将结果写入输出缓冲区。
```
![[Pasted image 20251013102655.png]]
#### 算法分析
- I/O 代价：$B(R)+B(S)$
	- build 阶段，S 的每块只读一次
	- probe 阶段，R 的每块只读一次
- 可用内存页数要求：$B(S) \leq M-1$
	- 内存查找结构约占 B(S) 页
- I/O 代价小，但内存开销大

### 基于元组的嵌套循环连接 Tuple-based Nested-Loop Join
#### 算法流程
小的放外层循环更合适
```
for S的每个元组s do
	for R的每个元组r do
		if r和s满足连接条件 then
			连接 rs，结果写入输出缓冲区
```
#### 算法分析
- I/O 代价：$T(S)(T(R)+1)$
	- 外关系 S 的每个元组只读一次，每次产生一个 IO
	- 内关系 R 的每个元组读 T(S) 次，每次产生一个 IO
- 可用内存页数要求：$M \geq 2$
	- 1 页作为读 S 的缓冲区
	- 1 页作为读 R 的缓冲区
#### 算法扩展
- 假设 B(S) < B(R)
- 可用内存数为 M
```
for S的每A块元组中的任意元素s do
	for R的每(M-A)块元组中的任意元组r do
		if r和s满足连接条件 then
			连接 rs，结果写入输出缓冲区
```
- I/O 代价：$(B(S)/A) \times (B(R)+A)$
- 相同内存页数 M 下，A 越大 I/O 代价越小，最优 A=M-1

### 基于块的嵌套循环连接 Block-based Nested-Loop Join
#### 算法流程
```
1. for 外关系S的每M-1块 do
2.     将这M-1块读入缓冲区
3.     用一个内存查找结构来组织这M-1块中的元组
4.     for 内关系R的每一块P do
5.         将P读入缓冲池
6.         for P中每条元组r do
7.             for 内存查找结构中能与r进行连接的元组s do
8.                 连接r和s,并将结果写入输出缓冲区
```
![[Pasted image 20251013105406.png]]
#### 算法分析
- I/O 代价：$B(S)+\frac{B(R)B(S)}{M-1}$
	- 外关系 S 的每个元组只读一次
	- 内关系 R 扫描 B(S)/(M-1) 次
- 可用内存页数要求：$M\geq 2$
	- 至少 1 页作为读 S 的缓冲区
	- 1 页作为读 R 的缓冲区

### 排序归并连接 Sort-Merge Join
```
1. // 创建归并段
2. 将R划分为⌈B(R)/M⌉个归并段(每个归并段按R.Y进行排序)
3. 将S划分为⌈B(S)/M⌉个归并段(每个归并段按S.Y进行排序)
4. // 归并
5. 读入R和S的每个归并段的第1页
6. Repeat
7.     找出输入缓冲区中元组Y属性的最小值y
8.     for R中满足R.Y = y的元组r do
9.         for S中满足S.Y = y的元组s do
10.            连接r和s,并将结果写入输出缓冲区
11.    任意输入缓冲页中的元组若归并完毕,则读入其归并段的下一页
12. until R或S的所有归并段都已归并完毕
```
![[Pasted image 20251013110930.png]]

![[Pasted image 20251013110950.png]]

#### 算法分析
- I/O 代价：$3B(R)+3B(S)$
	- 在对 R 创建归并段时，R 的每块只读一次
	- 将 R 的归并段全部写入文件，需 B(R) 次
	- 在对 S 创建 归并段时， S 的每块只读一次
	- 将 S 的归并段全部写入文件，需 B(S) 次
	- 在归并阶段，对 R 和 S 对每个归并段各扫描 1 次，合计 B(R)+B(S) 次
- 可用内存页数要求：$B(R)+B(S)<M^2$
	- R 和 S 对每个归并段均不超过 M 块
	- R 和 S 共有不超过 M 个归并段

### 哈希连接 Grace Hash Join
- R 和 S 中相同的元组一定分别落入同号桶 $R_i$ 和 $S_i$ 中
- $R \bowtie S = \cup_{i=1}^{M-1}(R_i \bowtie S_i)$
- $(R_i \bowtie S_i) \cap (Rj \bowtie S_j) = \emptyset \space\text{for}\space i \neq j$
#### 算法流程
```
1. // 哈希分桶    还有一页用来读取数据
2. 将R的元组哈希到M-1个桶R₁, R₂ ,..., R_{M-1}中(哈希键为R.Y)
3. 将S的元组哈希到M-1个桶S₁, S₂ ,..., S_{M-1}中(哈希键为S.Y)
4. // 逐桶连接
5. for i = 1, 2,..., M - 1 do
6.     使用一趟连接(one-pass join)算法计算R_i ⋈ S_i,并将结果写入输出缓冲区
```
#### 算法分析
- I/O 代价：$3B(R)+3B(S)$
	- 在对 R 进行哈希分桶时，R 的每块读一次
	- 将 R 的桶全部写入文件，需 $\Sigma_{i=1}^{M-1}(B(R_i))\approx B(R)$ 次
	- 在对 S 进行哈希分桶时，S 的每块读一次
	- 将 S 的桶全部写入文件，需 $\Sigma_{i=1}^{M-1}(B(S_i))\approx B(S)$ 次
	- 使用一趟集合差算法计算 $R_i \bowtie S_i$ 的 I/O 代价是 $B(R_i)+B(S_i)$
- 可用内存页数要求：$B(S)\leq (M-1)^2$
	- S 共有 M-1 个桶
	- 每个桶不超过 M-1 块

### 基于索引的连接 Index-based Join
假设：关系 S 上建有属性 Y 的索引
#### 算法流程
```
for R的每一块P do
	将P读入缓冲区
	for P中每一条元组r do
		在索引上查找键值等于r.Y的S的元组集合T
		for s ∈ T do
			连接 rs，结果写入输出缓冲区
```
![[Pasted image 20251013113243.png]]
#### 算法分析
- I/O 代价: $B(R) + \frac{T(R)T(S)}{V(S,Y)}$ (若索引是非聚集索引)
	- R 的每块只读 1 次,合计 B(R) 次 I/O
	- 对于 R 的每个元组 r, S 中平均约有$\frac{T(S)}{V(S,Y)}$个元组能与r连接
	- 因为索引是非聚集索引,这些元组在文件中不一定连续存储。最坏情况下,读每个元组产生 1 次 I/O,合计$\frac{T(R)T(S)}{V(S,Y)}$次I/O
- I/O代价: $B(R) + T(R)\lceil\frac{B(S)}{V(S,Y)}\rceil$ (若索引是聚集索引)
	- 因为索引是聚簇索引,所以对于 R 的每个元组 r, S 中能与 r 连接的元组一定连续存储于 S 的文件中,约占$\lceil\frac{B(S)}{V(S,Y)}\rceil$个块
- 可用内存页数要求: $M \geq 2$
  • 1 页作为读 R 缓冲区
  • 1 页作为读索引节点缓冲区