$R(X, Y) \bowtie S(Y,Z)$
基本符号：
- $T(R)$: 关系 R 的元组数
- $T(S)$: 关系 S 的元组数
- $B(R)$: 关系 R 的块数
- $B(S)$: 关系 S 的块数
- $M$: 缓冲区可用内存页数
- $V(R, A)$: 关系 R 的属性集 A 的不同值的个数
- $V(S, A)$: 关系 S 的属性集 A 的不同值的个数

### 一趟连接算法 One-Pass Join
#### 算法流程
假设 $B(S)<B(R)$
```
// 构建(build)阶段
1. 构建阶段
2. 在M-1个可用内存页中建立一个内存查找结构(哈希表或平衡二叉树)，查找键是S.Y
3. for S的每一块P
4.     将P读入缓冲区
5.     将P中元组插入内存查找结构
// 探测(probe)阶段
6. 探测阶段
7. for R的每一块P do
8.     将P读入缓冲区
9.     for P中每条元组r do
10.        for 内存查找结构中每条键值等于r.Y的元组s do
11.            连接r和s，并将结果写入输出缓冲区。
```
![[Pasted image 20251013102655.png]]
#### 算法分析
- I/O 代价：$B(R)+B(S)$
	- build 阶段，S 的每块只读一次
	- probe 阶段，R 的每块只读一次
- 可用内存页数要求：$B(S) \leq M-1$
	- 内存查找结构约占 B(S) 页
- I/O 代价小，但内存开销大

### 基于元组的嵌套循环连接 Tuple-based Nested-Loop Join
#### 算法流程
小的放外层循环更合适
```
for S的每个元组s do
	for R的每个元组r do
		if r和s满足连接条件 then
			连接 rs，结果写入输出缓冲区
```
#### 算法分析
- I/O 代价：$T(S)(T(R)+1)$
	- 外关系 S 的每个元组只读一次，每次产生一个 IO
	- 内关系 R 的每个元组读 T(S) 次，每次产生一个 IO
- 可用内存页数要求：$M \geq 2$
	- 1 页作为读 S 的缓冲区
	- 1 页作为读 R 的缓冲区
#### 算法扩展
- 假设 B(S) < B(R)
- 可用内存数为 M
```
for S的每A块元组中的任意元素s do
	for R的每(M-A)块元组中的任意元组r do
		if r和s满足连接条件 then
			连接 rs，结果写入输出缓冲区
```
- I/O 代价：$(B(S)/A) \times (B(R)+A)$
- 相同内存页数 M 下，A 越大 I/O 代价越小，最优 A=M-1

### 基于块的嵌套循环连接 Block-based Nested-Loop Join
#### 算法流程
```
1. for 外关系S的每M-1块 do
2.     将这M-1块读入缓冲区
3.     用一个内存查找结构来组织这M-1块中的元组
4.     for 内关系R的每一块P do
5.         将P读入缓冲池
6.         for P中每条元组r do
7.             for 内存查找结构中能与r进行连接的元组s do
8.                 连接r和s,并将结果写入输出缓冲区
```
![[Pasted image 20251013105406.png]]
#### 算法分析
- I/O 代价：$B(S)+\frac{B(R)B(S)}{M-1}$
	- 外关系 S 的每个元组只读一次
	- 内关系 R 扫描 B(S)/(M-1) 次
- 可用内存页数要求：$M\geq 2$
	- 至少 1 页作为读 S 的缓冲区
	- 1 页作为读 R 的缓冲区

### 排序归并连接 Sort-Merge Join
```
1. // 创建归并段
2. 将R划分为⌈B(R)/M⌉个归并段(每个归并段按R.Y进行排序)
3. 将S划分为⌈B(S)/M⌉个归并段(每个归并段按S.Y进行排序)
4. // 归并
5. 读入R和S的每个归并段的第1页
6. Repeat
7.     找出输入缓冲区中元组Y属性的最小值y
8.     for R中满足R.Y = y的元组r do
9.         for S中满足S.Y = y的元组s do
10.            连接r和s,并将结果写入输出缓冲区
11.    任意输入缓冲页中的元组若归并完毕,则读入其归并段的下一页
12. until R或S的所有归并段都已归并完毕
```